#!/bin/bash

# BOSH Specific. We need to install the DPKG blob in-situ and symlink to /opt/sensu due to hard coding of a lot of the #!ruby in the sensu pkg

BOSH_PACKAGE_NAME=sensu_client
EXTENSION_DIR=/var/vcap/jobs/$BOSH_PACKAGE_NAME/etc/sensu/extensions

   dpkg --remove --force-remove-reinstreq sensu || :
   dpkg --remove --force-remove-reinstreq nagios-plugins-standard || :
   dpkg --remove --force-remove-reinstreq nagios-plugins-basic || :
   dpkg --remove --force-remove-reinstreq nagios-plugins || :

   dpkg --instdir=/var/vcap/jobs/sensu_client --unpack -E /var/vcap/packages/sensu_client/sensu_0.12.6-5_amd64.deb || :
   dpkg --instdir=/var/vcap/jobs/sensu_client --unpack -E /var/vcap/packages/sensu_client/nagios-plugins-basic_1.4.14-1ubuntu1_amd64.deb || :
   dpkg --instdir=/var/vcap/jobs/sensu_client --unpack -E /var/vcap/packages/sensu_client/nagios-plugins-standard_1.4.14-1ubuntu1_amd64.deb || :
   dpkg --instdir=/var/vcap/jobs/sensu_client --unpack -E /var/vcap/packages/sensu_client/nagios-plugins_1.4.14-1ubuntu1_all.deb || :
  

   # Sensu ruby modules have hard coded path to ruby under /opt/sentu
   rm -f /opt/sensu
   mkdir -p /opt
   ln -s /var/vcap/jobs/sensu_client/opt/sensu /opt/sensu

   # Symlink for NRPE path compatability (sharing sensu checks with our puppet controlled infra)
   rm -Rf /usr/lib64/nagios
   rm -Rf /usr/lib/nagios
   mkdir -p /usr/lib64/nagios
   mkdir -p /usr/lib/nagios
   ln -s /var/vcap/jobs/sensu_client/usr/lib/nagios/plugins /usr/lib64/nagios/
   ln -s /var/vcap/jobs/sensu_client/usr/lib/nagios/plugins /usr/lib/nagios/

# description: Sensu monitoring framework service

prog=sensu-$1
system=debian

EMBEDDED_RUBY=true
CONFIG_FILE=/var/vcap/jobs/$BOSH_PACKAGE_NAME/etc/sensu/config.json
CONFIG_DIR=/var/vcap/jobs/$BOSH_PACKAGE_NAME/etc/sensu/conf.d
PLUGINS_DIR=/var/vcap/jobs/$BOSH_PACKAGE_NAME/etc/sensu/plugins
HANDLERS_DIR=/var/vcap/jobs/$BOSH_PACKAGE_NAME/etc/sensu/handlers
LOG_DIR=/var/vcap/sys/log/$BOSH_PACKAGE_NAME
LOG_LEVEL=info
PID_DIR=/var/vcap/sys/run/$BOSH_PACKAGE_NAME
USER=root
SERVICE_MAX_WAIT=10

##
## Set platform specific bits here.
## The original platform for this script was redhat so the scripts are partial
## to redhat style. Eventually we may want to be more LSB compliant
## such as what Debian platforms already implement instead.
##
## Each platform must implement at least the following functions:
##
##     start_daemon $user $pidfile $executable "arguments"
##

if [ "$system" = "debian" ]; then

    ## set or override platform specific variables
    lockfile=/var/vcap/sys/run/$BOSH_PACKAGE_NAME/$prog

    ## set or override platform specific functions
    start_daemon() {
        start-stop-daemon --start --chuid $1 --pidfile $2 --exec $3 -- $4
    }
fi

cd /var/vcap/jobs/$BOSH_PACKAGE_NAME/opt/

exec=/var/vcap/jobs/$BOSH_PACKAGE_NAME/opt/sensu/bin/$prog

pidfile=$PID_DIR/$prog.pid
logfile=$LOG_DIR/$prog.log

options="-b -c $CONFIG_FILE -d $CONFIG_DIR -e $EXTENSION_DIR -p $pidfile -l $logfile -L $LOG_LEVEL $OPTIONS"

ensure_dir() {
    if [ ! -d $1 ]; then
        mkdir -p $1
        chown -R $2 $1
        chmod 755 $1
    fi
}

set_sensu_paths() {
    if [ "x$EMBEDDED_RUBY" = "xtrue" ]; then
        export PATH=/var/vcap/jobs/$BOSH_PACKAGE_NAME/opt/sensu/embedded/bin:$PATH:$PLUGINS_DIR:$HANDLERS_DIR
        export GEM_PATH=/var/vcap/jobs/$BOSH_PACKAGE_NAME/opt/sensu/embedded/lib/ruby/gems/2.0.0:$GEM_PATH
    else
        export PATH=$PATH:$PLUGINS_DIR:$HANDLERS_DIR
    fi
}

start() {

    [ -x $exec ] || exit 5

    status &> /dev/null

    if [ $? -eq 0 ]; then
        log_action_msg "$prog is already running."
        echo_ok
        exit 0
    fi

    set_sensu_paths
    ensure_dir $PID_DIR $USER
    ensure_dir $LOG_DIR $USER

    start_daemon $USER $pidfile $exec "$options"

    retval=$?
    sleep 1

    # make sure it's still running. some errors occur only after startup
    status &> /dev/null
    if [ $? -ne 0 ]; then
        echo_fail
        exit 1
    fi

    if [ $retval -eq 0 ]; then
        touch $lockfile
    fi
    echo_ok

    return $retval
}

stop() {

    if [ -f $pidfile ]; then
        kill -9 `cat /var/vcap/sys/run/sensu_client/sensu-client.pid`
        retval=$?
        if [ $retval -eq 0 ]; then
            rm -f $pidfile
            rm -f $lockfile
            echo_ok
        else
            echo_fail
        fi
        return $retval
    else
        pid=$(pgrep -P1 -fl $exec | grep -v grep | grep -v bash | cut -f1 -d" ")
        if [ ! "$pid" == "" ]; then
            kill -9 $pid
            retval=$?
            if [ $retval -eq 0 ]; then
                rm -f $pidfile
                rm -f $lockfile
                echo_ok
            fi
        else
            echo_fail
        fi
    fi
}

status() {
    local pid

    # First try "ps"
    pid=$(pgrep -P1 -fl $exec | grep -v grep | grep -v bash | cut -f1 -d" ")
    if [ -n "$pid" ]; then
        log_action_msg $"${prog} (pid $pid) is running..."
        return 0
    fi

    # Next try "/var/run/*.pid" files
    if [ -f "$pidfile" ] ; then
        read pid < "$pidfile"
        if [ -n "$pid" ]; then
            log_action_msg $"${prog} dead but pid file exists"
            return 1
        fi
    fi

    # See if $lockfile
    if [ -f "$lockfile" ]; then
        log_action_msg $"${prog} dead but subsys locked"
        return 2
    fi

    log_action_msg $"${prog} is stopped"
    return 3
}

# sometimes sensu components need a moment to shutdown, so
# let's implement a waiting approach to restarts with a timeout
restart() {

    stop
    start
}

case "$2" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    status)
        status
        ;;
    restart)
        restart
        ;;
    *)
        echo "Usage: $0 client {start|stop|status|restart}"
        exit 2
esac

exit $?


